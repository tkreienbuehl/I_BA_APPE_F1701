% !TEX root = Dokumentation_SysSpec.tex
\subsection{Modelle und Sichten}

\subsubsection{Kontextdiagramm}
Die entwickelte Applikation hat folgende Abhängigkeiten/Umsysteme/Akteuere:
\begin{figure}[H]
	\includegraphics[width=1.0\linewidth]{Images/kontextdiagram}
	\caption{Kontextdiagram}
	\label{fig:kontextdiagram}
\end{figure}

\textbf{Umsysteme}:
\begin{itemize}
\item Zentrallager: Nachbestellungen des lokalen Filiallagers werden an das Zentrallager gesendet.
\item Rechnungswesen: Das Rechnungswesen wird für Bestell-Bestätigungen, Rechnungsversand und Mahnungsprüfungen verwendet.
\item Filiallager: Lagerung der in der Filiale verkauften Artikel. Filiallager und Applikation müssen jederzeit einen übereinstimmenden Datenbestand haben.
\end{itemize}

\textbf{Akteuere}:
\begin{itemize}
\item Benutzer: Bestehend aus Filialverwalter, Filialleiter, Verkaufspersonal und Datentypist, bezeichnet alle Nutzer der Applikation. Die einzelnen Aktionen sind in der Use Case Übersicht ersichtlich
\item Sysadmin: Gemäss Anforderungen kein eigentlicher Benutzer. Für konfigurative Anpassungen könnte ein Zugriff notwendig sein
\item Kunde: Interaktion mit der Applikation wird via Verkaufspersonal abgewickelt.
\end{itemize}


\subsubsection{Layer-Architektur}
TODO Übersichsgrafik importieren und erläutern

\subsubsection{Client-Layer}
Der Client-Layer ist in JavaFX implementiert und verwendet das MVC-Architektur-Pattern. Zur Gestaltung der Oberfläche wurde ein 3rd Party Tool eingesetzt, um die graphische Gestaltung zu vereinfachen.
\begin{itemize}
\item Scene Builder by Gluon: Basiert auf der von Oracle entwickelten JavaFX-Distribution, und erstellt ein passendes FXML-Dokument für die Einbindung der graphischen Oberfläche, inklusive Verlinkung und definition der Event-Handler. 
\end{itemize}
\begin{figure}[H]
	\includegraphics[width=1.0\linewidth]{Images/ClientLayer-Architektur}
	\caption{Architektur des Clientlayer}
	\label{fig:clientlayer-architektur}
\end{figure}

\textbf{View}: Die View ist dafür verantwortlich, dass die angezeigte Oberfläche korrekt geladen ist.

\textbf{Controller}: Die Controller binden die FXML-Dokumente ein. Die Controller registrieren ausgelöste Events und steuern die durchzufürenden Aktionen, wie Datenabfragen vom Business-Layer durch.

\textbf{Model}: Im Model befinden sich die im GUI angezeigten Datenwerte, und sind bereits durch die Verwendung von Property-Klassen als Observable-Objekte abgespeichert.

\textbf{Session}: Die Session enthält die User-Informationen. Die Session-Informationen werden bei Aktionen mitgesendet, um unauthorisierte Aufrufe zu unterbinden.

\subsubsection{Remote-Layer}
\begin{figure}[H]
	\includegraphics[width=1.0\linewidth]{Images/RemoteLayer-Architektur}
	\caption{Architektur des Remotelayer}
	\label{fig:remotelayer-architektur}
\end{figure}

\subsubsection{Business-Layer}
\begin{figure}[H]
	\includegraphics[width=1.0\linewidth]{Images/BusinessLayer-Architektur}
	\caption{Architektur des Businesslayer}
	\label{fig:businesslayer-architektur}
\end{figure}

\subsubsection{Data-Layer}
\begin{figure}[H]
	\includegraphics[width=1.0\linewidth]{Images/DataLayer-Architektur}
	\caption{Architektur des Datalayer}
	\label{fig:datalayer-architektur}
\end{figure}

\subsubsection{UML-Klassendiagramme}
todo


\subsubsection{Sequenzdiagramme}
todo


\subsection{Entwurfsentscheid}
Im Rahmen der Architekturausarbeitung wurden folgende Entwurfsentscheide gefällt:
\begin{itemize}
	\item Für Testzwecke und statische Datenstrukturen werden teilweise Stubs eingesetzt. Beispielsweise sind die Zuweisung Benutzerrollen zu deren Berechtigungen bis Release 1.0 als Stub abgebildet.
	\item Der Business-Layer und Data-Layer (ohne Datenbank, nur OR-Mapper) befinden sich auf dem gleichen Tier. Bis Release 1.0 werden, aus zeitlichen Gründen, keine Bestrebungen zur Aufteilung dieser Layers auf verschiedene Tiers vorgenommen
	\item Die Tier-übergreifende Kommunikation zwischen Tier Client und Business wird mittels RMI (Remote Method Invocation) umgesetzt. Eine alternative Anbindung bspw. mit REST (Representational state transfer) wird nach Release 1.0 in Betracht gezogen.
	\item Als GUI-Komponente auf Layer Client wird JavaFX verwendet.
	\item Als Datenbank wird eine MySQL-Instanz aus dem EnterpriseLab der HSLU verwendet.
	\item Bis Release 1.0 müssen neue Kunden \& Artikel in der Datenbank manuell erfasst / abgebildet werden. Diese werden idealerweise mit einer zentralen Benutzerverwaultung (Rechnungswesen, Zentrallager) in folgenden Releases zusammengeführt.
	\item Die Rechnungsdaten und Mahnungen werden aufgrund in einem Stub generiert. Die Anbindung eines beliebigen, externen Rechnungswesen ist dadurch in folgenden Releases schneller zu bewältigen.
\end{itemize}

TODO
- Dateien einbinden (DB) -> Transaktionsmanagement


\subsection{Datenmodell}
Der Aufbau der Datenbank ist in folgender Abbildung dargestellt.
\begin{figure}[H]
	\includegraphics[width=1.0\linewidth]{Images/datamodel}
	\caption{Datenmodel}
	\label{fig:datamodel}
\end{figure}
Die Datenbank ist funktional aufgebaut und befolgt die ersten 3 Normalformen. Die Anbindung von Umsystemen sind im Datenmodell bereits abgebildet, sind jedoch nicht in der Datenbank vorhanden. Die abgebildeten Umsysteme sind WarningCheck, InvoiceRequest und OrderConfirmation.
